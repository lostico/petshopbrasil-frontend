import { Component, Input, Output, EventEmitter, OnInit, OnChanges, SimpleChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ScheduleAppointment } from '../schedule-table/schedule-table.component';

export interface SlotClickEvent {
  hour: number;
  minute: number;
}

@Component({
  selector: 'app-schedule-timeline',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="bg-white rounded-lg border border-secondary-200 flex flex-col overflow-hidden">
      <!-- Cabeçalho do Recurso -->
      <div class="flex items-center justify-center gap-2 px-6 py-4 border-b border-secondary-200 flex-shrink-0">
        <div
          class="w-3 h-3 rounded-full flex-shrink-0"
          [style.background-color]="resourceColor">
        </div>
        <span class="text-sm font-medium text-secondary-900">
          {{ resourceName }}@if (resourceCategory) { ({{ resourceCategory }}) }
        </span>
      </div>

      <!-- Container Principal com Scroll -->
      <div class="flex relative overflow-y-auto scrollbar-visible" [style.max-height.px]="getMaxScrollHeight()">
        <!-- Linha do Tempo Vertical -->
        <div class="w-20 flex-shrink-0 border-r border-secondary-200 bg-secondary-50" style="height: {{ totalHeight }}px;">
          @for (hour of timeSlots; track hour) {
            <div
              class="border-b border-secondary-200 flex items-start justify-end pr-3 pt-1"
              [style.height.px]="hourHeight ?? dynamicHourHeight"
              [class.border-secondary-300]="hour === startHour">
              <span class="text-xs font-medium text-secondary-600">
                {{ formatHour(hour) }}
              </span>
            </div>
          }
        </div>

        <!-- Área de Agendamentos -->
        <div
          class="flex-1 relative"
          (click)="onGridClick($event)"
          style="height: {{ totalHeight }}px; min-height: {{ totalHeight }}px;">
          <!-- Linhas de Grade (a cada 15 minutos) -->
          @for (slotMinutes of timeSlots15Min; track slotMinutes) {
            <div
              class="absolute left-0 right-0 border-b"
              [style.top.px]="getSlotPosition(slotMinutes)"
              [class.border-secondary-300]="slotMinutes % 60 === 0"
              [class.border-secondary-200]="slotMinutes % 60 !== 0">
            </div>
          }

          <!-- Linha do Horário Atual -->
          @if (currentTimePosition !== null) {
            <div
              class="absolute left-0 right-0 z-10 pointer-events-none"
              [style.top.px]="currentTimePosition">
              <!-- Círculo Vermelho (alinhado com linha do tempo à esquerda) -->
              <div class="absolute -left-2.5 top-1/2 -translate-y-1/2 w-3 h-3 bg-red-500 rounded-full border-2 border-white z-10"></div>
              <!-- Linha Vermelha -->
              <div class="h-0.5 bg-red-500"></div>
            </div>
          }

          <!-- Agendamentos -->
          @for (appointment of appointments; track appointment.id) {
            <div
              class="appointment-block absolute left-2 right-2 rounded-md p-2 cursor-pointer transition-all hover:shadow-md z-20 overflow-hidden"
              [style.top.px]="getAppointmentTop(appointment)"
              [style.height.px]="getAppointmentHeight(appointment)"
              [style.min-height.px]="getMinAppointmentHeight()"
              [class]="getAppointmentClasses(appointment)"
              (click)="onAppointmentClick(appointment, $event)">
              <div class="text-xs font-medium text-white truncate">
                {{ appointment.time }} - {{ appointment.petName }} ({{ appointment.tutorName }}) - {{ appointment.service }}
              </div>
            </div>
          }
        </div>
      </div>
    </div>
  `,
  styles: [`
    :host {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    .scrollbar-visible {
      scrollbar-width: thin;
      scrollbar-color: #cbd5e1 #f1f5f9;
    }
    
    .scrollbar-visible::-webkit-scrollbar {
      width: 12px;
    }
    
    .scrollbar-visible::-webkit-scrollbar-track {
      background: #f1f5f9;
      border-radius: 6px;
    }
    
    .scrollbar-visible::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 6px;
      border: 2px solid #f1f5f9;
    }
    
    .scrollbar-visible::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
  `]
})
export class ScheduleTimelineComponent implements OnInit, OnChanges {
  @Input() appointments: ScheduleAppointment[] = [];
  @Input() resourceName: string = '';
  @Input() resourceCategory: string = '';
  @Input() resourceColor: string = '#3B82F6';
  @Input() startHour: number = 9;
  @Input() endHour: number = 20;
  @Input() currentTime?: Date;
  // Configurações de altura da timeline (podem ser configuradas por agenda)
  @Input() hourHeight?: number; // Altura FIXA de 1 hora em pixels. Se não fornecido, será calculado dinamicamente
  @Input() minHourHeight: number = 40; // Altura MÍNIMA de 1 hora em pixels (usado no cálculo dinâmico)
  @Input() maxHourHeight: number = 120; // Altura MÁXIMA de 1 hora em pixels (usado no cálculo dinâmico)
  @Input() intervalMinutes: number = 15; // Intervalo entre as linhas de grade em minutos (15, 30, 60, etc.)
  @Input() minIntervalHeight: number = 15; // Altura MÍNIMA de cada intervalo em pixels (garante que cada intervalo tenha espaço mínimo)

  @Output() slotClick = new EventEmitter<SlotClickEvent>();
  @Output() appointmentClick = new EventEmitter<ScheduleAppointment>();

  timeSlots: number[] = []; // Horas inteiras para exibição na linha do tempo
  timeSlots15Min: number[] = []; // Slots de 15 em 15 minutos para linhas de grade
  totalHeight: number = 0;
  currentTimePosition: number | null = null;
  dynamicHourHeight: number = 60; // Altura calculada dinamicamente

  ngOnInit(): void {
    this.calculateDynamicHourHeight();
    this.generateTimeSlots();
    this.updateCurrentTimePosition();
  }

  ngOnChanges(changes: SimpleChanges): void {
    // Recalcular altura quando propriedades relevantes mudarem
    if (changes['appointments'] || 
        changes['hourHeight'] || 
        changes['minHourHeight'] || 
        changes['maxHourHeight'] || 
        changes['intervalMinutes'] || 
        changes['minIntervalHeight']) {
      this.calculateDynamicHourHeight();
    }
    
    if (changes['startHour'] || 
        changes['endHour'] || 
        changes['hourHeight'] || 
        changes['appointments'] ||
        changes['intervalMinutes']) {
      this.generateTimeSlots();
      this.updateCurrentTimePosition();
    }
    
    if (changes['currentTime']) {
      this.updateCurrentTimePosition();
    }
  }

  calculateDynamicHourHeight(): void {
    // Se hourHeight foi fornecido explicitamente, usar esse valor
    if (this.hourHeight !== undefined && this.hourHeight !== null) {
      this.dynamicHourHeight = this.hourHeight;
      return;
    }

    // Calcular altura mínima baseada no tamanho mínimo por intervalo
    // Se cada intervalo precisa ter pelo menos minIntervalHeight pixels,
    // então cada hora precisa ter pelo menos (60 / intervalMinutes) * minIntervalHeight pixels
    const intervalsPerHour = 60 / this.intervalMinutes;
    const minHeightByInterval = intervalsPerHour * this.minIntervalHeight;
    const minHeightRequired = Math.max(this.minHourHeight, minHeightByInterval);

    // Calcular altura dinâmica baseada nos agendamentos
    if (this.appointments.length === 0) {
      // Sem agendamentos, usar altura mínima baseada no intervalo
      this.dynamicHourHeight = Math.max(60, minHeightRequired);
      return;
    }

    const totalHours = this.endHour - this.startHour + 1;
    const totalMinutes = totalHours * 60;
    
    // Calcular a duração total de todos os agendamentos
    let totalAppointmentDuration = 0;
    let maxConcurrentAppointments = 0;
    
    // Criar um mapa de minutos para contar agendamentos simultâneos
    const minuteMap = new Map<number, number>();
    
    this.appointments.forEach(appointment => {
      const duration = appointment.duration || 30; // minutos
      totalAppointmentDuration += duration;
      
      const [startHours, startMins] = appointment.time.split(':').map(Number);
      const startTotalMinutes = startHours * 60 + startMins;
      const endTotalMinutes = startTotalMinutes + duration;
      
      // Contar agendamentos simultâneos usando o intervalo configurado
      for (let min = startTotalMinutes; min < endTotalMinutes; min += this.intervalMinutes) {
        const relativeMin = min - (this.startHour * 60);
        if (relativeMin >= 0 && relativeMin < totalMinutes) {
          minuteMap.set(relativeMin, (minuteMap.get(relativeMin) || 0) + 1);
          maxConcurrentAppointments = Math.max(maxConcurrentAppointments, minuteMap.get(relativeMin) || 0);
        }
      }
    });

    // Calcular altura baseada na densidade de agendamentos
    // Se houver muitos agendamentos simultâneos, aumentar a altura
    const baseHeight = minHeightRequired;
    const densityFactor = Math.max(1, maxConcurrentAppointments * 0.3);
    const calculatedHeight = baseHeight * densityFactor;
    
    // Aplicar limites (garantindo que o mínimo por intervalo seja respeitado)
    this.dynamicHourHeight = Math.max(
      minHeightRequired,
      Math.min(this.maxHourHeight, calculatedHeight)
    );
  }

  generateTimeSlots(): void {
    // Horas inteiras para exibição na linha do tempo vertical
    this.timeSlots = [];
    for (let hour = this.startHour; hour <= this.endHour; hour++) {
      this.timeSlots.push(hour);
    }
    
    // Slots baseados no intervalo configurado para linhas de grade
    this.timeSlots15Min = [];
    const startMinutes = this.startHour * 60;
    const endMinutes = (this.endHour + 1) * 60; // Incluir a hora final
    
    for (let minutes = startMinutes; minutes < endMinutes; minutes += this.intervalMinutes) {
      this.timeSlots15Min.push(minutes);
    }
    
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    this.totalHeight = (this.endHour - this.startHour + 1) * effectiveHourHeight;
  }

  getMaxScrollHeight(): number {
    // Altura máxima para scroll interno da timeline
    // Se o conteúdo for muito grande, limitar a altura para ativar scroll interno
    // Caso contrário, deixar crescer naturalmente e permitir scroll da página principal
    const viewportHeight = typeof window !== 'undefined' ? window.innerHeight : 800;
    const headerHeight = 300; // Altura aproximada do cabeçalho, página e outros elementos
    const maxInternalHeight = viewportHeight - headerHeight;
    
    // Se o conteúdo for menor que a altura máxima interna, não limitar (deixar crescer)
    // Caso contrário, limitar para ativar scroll interno
    if (this.totalHeight <= maxInternalHeight) {
      return this.totalHeight;
    }
    
    // Limitar altura para ativar scroll interno quando conteúdo for muito grande
    return maxInternalHeight;
  }

  formatHour(hour: number): string {
    return `${hour.toString().padStart(2, '0')}:00`;
  }

  getHourPosition(hour: number): number {
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    return (hour - this.startHour) * effectiveHourHeight;
  }

  getSlotPosition(minutes: number): number {
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    const startMinutes = this.startHour * 60;
    const relativeMinutes = minutes - startMinutes;
    return (relativeMinutes / 60) * effectiveHourHeight;
  }

  parseTimeToMinutes(time: string): number {
    const [hours, minutes] = time.split(':').map(Number);
    const startMinutes = this.startHour * 60;
    return (hours * 60 + minutes) - startMinutes;
  }

  getAppointmentTop(appointment: ScheduleAppointment): number {
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    const minutes = this.parseTimeToMinutes(appointment.time);
    return (minutes / 60) * effectiveHourHeight;
  }

  getAppointmentHeight(appointment: ScheduleAppointment): number {
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    // Assumir 30 minutos padrão se não houver duração
    const duration = appointment.duration || 30; // minutos
    
    // Calcular altura baseada nos intervalos configurados
    // Altura de um intervalo = altura da hora / (60 / intervalMinutes)
    // Exemplo: se intervalMinutes = 30, altura do intervalo = hourHeight / 2
    // Se duration = 60min e intervalMinutes = 30, ocupará 2 intervalos
    const intervalsPerHour = 60 / this.intervalMinutes;
    const intervalHeight = effectiveHourHeight / intervalsPerHour;
    const numberOfIntervals = duration / this.intervalMinutes;
    const calculatedHeight = numberOfIntervals * intervalHeight;
    
    // Garantir que a altura seja pelo menos a altura mínima necessária
    return Math.max(calculatedHeight, this.getMinAppointmentHeight());
  }

  getMinAppointmentHeight(): number {
    // Altura mínima para exibir todo o conteúdo sem scroll:
    // padding (p-2 = 8px top + 8px bottom = 16px)
    // + linha única com horário, pet, tutor e serviço (text-xs ~16px)
    // Total aproximado: 16 + 16 = 32px
    // Adicionando margem de segurança: 40px
    return 40;
  }

  getAppointmentClasses(appointment: ScheduleAppointment): string {
    const baseClasses = 'border-l-4';
    const statusColors: Record<string, string> = {
      'confirmed': 'bg-primary-500 border-primary-600',
      'pending': 'bg-warning-500 border-warning-600',
      'in-progress': 'bg-success-500 border-success-600',
      'completed': 'bg-secondary-500 border-secondary-600',
      'no-show': 'bg-danger-500 border-danger-600',
      'cancelled': 'bg-secondary-400 border-secondary-500'
    };
    return `${baseClasses} ${statusColors[appointment.status] || statusColors['pending']}`;
  }

  updateCurrentTimePosition(): void {
    const timeToUse = this.currentTime || new Date();
    const now = new Date(timeToUse);
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const startMinutes = this.startHour * 60;
    const endMinutes = this.endHour * 60;
    
    if (currentMinutes < startMinutes || currentMinutes > endMinutes) {
      this.currentTimePosition = null;
      return;
    }
    
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    this.currentTimePosition = ((currentMinutes - startMinutes) / 60) * effectiveHourHeight;
  }

  onGridClick(event: MouseEvent): void {
    // Verificar se o clique foi em um agendamento
    const target = event.target as HTMLElement;
    const appointmentElement = target.closest('.appointment-block');
    if (appointmentElement) {
      // Clique foi em um agendamento, não processar aqui
      return;
    }

    const rect = (event.currentTarget as HTMLElement).getBoundingClientRect();
    const y = event.clientY - rect.top;
    
    // Calcular hora e minuto baseado na posição Y
    const effectiveHourHeight = this.hourHeight ?? this.dynamicHourHeight;
    const totalMinutes = (y / effectiveHourHeight) * 60;
    const clickedHour = Math.floor(totalMinutes / 60) + this.startHour;
    const clickedMinute = Math.floor(totalMinutes % 60);
    
    // Arredondar para o slot mais próximo baseado no intervalo configurado
    const roundedMinute = Math.round(clickedMinute / this.intervalMinutes) * this.intervalMinutes;
    const finalMinute = roundedMinute === 60 ? 0 : roundedMinute;
    const finalHour = roundedMinute === 60 ? clickedHour + 1 : clickedHour;
    
    if (finalHour >= this.startHour && finalHour <= this.endHour) {
      this.slotClick.emit({ hour: finalHour, minute: finalMinute });
    }
  }

  onAppointmentClick(appointment: ScheduleAppointment, event: MouseEvent): void {
    event.stopPropagation();
    this.appointmentClick.emit(appointment);
  }
}

